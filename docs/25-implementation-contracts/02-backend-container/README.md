---
doc_type: "unknown"
status: "draft"
depends:
  contracts:
    - "backend-container-integrated-constraints"
    - "backend-architecture-style"
  produces: []
---

# 02-backend-container - バックエンドモジュール設計

## 概要

Container レベルでのバックエンド実装契約を定義する。What 系で決定された設計判断を、実行可能単位レベルの具体的な実装契約に落とし込む。

## 前提制約

<!-- PREMISE_BEGIN: backend-container-integrated-constraints -->

### 物理配置

- セルフホスト環境の Docker コンテナとして API + SQLite 提供

### 技術スタック

- 言語・フレームワーク: Python + FastAPI
- アプリケーションサーバー: uvicorn
- ORM・マイグレーション: SQLAlchemy + Alembic
- バリデーション: Pydantic
- HTTP クライアント: httpx
- ログ・モニタリング: loguru
- 設定管理: 環境変数方式
- テストフレームワーク: pytest + FastAPI TestClient + pytest-asyncio + pytest-mock + httpx-mock + time-machine

### アーキテクチャ方針

- レイヤードアーキテクチャ採用
- 階層的な責務分離
- 機能境界に基づく水平分割
- 薄いドメイン層アプローチ
- モジュール分離による機能独立
- ステートレス実装

### API 契約

- エンティティ操作 API: 概念 API、文献メモ API、関係性 API、文献 API
- 検索・発見 API: 概念検索 API、質問から概念候補提示 API
- 協働・処理 API: LLM 要約生成 API、記事取得 API、バックアップ API
- REST API 採用
- JSON 形式 API・CQS 設計対応
- HTTP ステータスコードエラーハンドリング
- API ドキュメント生成(FastAPI 内蔵 Swagger UI・ReDoc)

### 機能境界と責務

- コア知識管理境界: 概念管理、文献メモ管理、関係性管理、質問探索を統合
  - データベース操作とトランザクション境界を重点検証
  - データ整合性と応答時間を監視
- LLM 統合境界: LLM API による要約生成、概念候補提示、協働プロセス制御
  - 外部 API の契約テストと異常ケース対応を強化
  - 外部 API 依存性を監視
- コンテンツ取得境界: 外部記事取得、内容解析、品質チェック
  - 構造変更への適応性を継続検証
  - 取得成功率と構造変更を追跡

### ドメインモデル

- 4 つのエンティティに対して基本的な CRUD 操作と最小限のビジネス制約
- 複雑なドメインロジックはアプリケーション層に委ねる
- ORM モデルと制約の連携
- データベース制約による整合性管理

### データモデル

- 概念エンティティ: 思考の最小単位として知識体系の中心に位置し、外部情報を個人の理解に変換するフィルターとして機能
- 文献メモエンティティ: ツェッテルカステン方式による概念ベースの知識蓄積として、LLM 協働により効率的に作成され個人の理解で修正される
- 関係性エンティティ: 概念間の無向グラフ構造による知識ネットワーク形成として、個人的な関係語彙による柔軟な関係定義と空間配置による直感的な関係性発見を支援
- 文献エンティティ: 外部文献の書誌情報管理として複数の概念観点から文献メモが生成される元情報

### トランザクション制御

- セッション管理とトランザクション制御
- 分離レベル設定
- テーブルアクセス順序制御と例外処理
- パラメータ化クエリによる SQL インジェクション対策

### パフォーマンス

- システム初回起動パフォーマンスバジェット対応
- eager loading による N+1 問題対策
- 単一プロセス・単一サーバー実行
- worker プロセス数調整
- タイムアウト設定

### 外部 API 通信

- 利用規約準拠の外部 API 通信
- タイムアウト・リトライ設定
- 外部 API 処理の分離

### ログ・監視

- 階層的ログレベル管理(ERROR、WARN、INFO、DEBUG)
- 機能別ログ出力
- 緊急度分類
- パフォーマンスログ出力
- ファイル出力とローテーション

### バッチ仕様

- 日次データバックアップのみを実装
- 全データの完全バックアップを日次実行
- バックアップ処理ログ出力
- システム障害時の迅速復旧を支援

### セキュリティ

- 入力バリデーション(型・範囲・形式チェック)
- API キー管理と利用規約遵守
- HTTP/HTTPS 両対応(開発環境)

### サービス間通信

- 単一バックエンドとの統合
- モジュール間協調
- フロントエンドからの独立
- データ保存制御
- 手動復旧手順の実装

### 不足技術要素

- トランザクション境界検証(pytest-sqlalchemy)
- CPU・メモリ使用量監視(psutil・htop)
- リバースプロキシレベルセキュリティヘッダー設定(Caddy・nginx)
- 高度なロック制御機構(MySQL/PostgreSQL レベル)

<!-- PREMISE_END: backend-container-integrated-constraints -->

<!-- PREMISE_BEGIN: backend-architecture-style -->

CogitoWeave のバックエンドアーキテクチャスタイルとして**レイヤードアーキテクチャ**を採用する。階層的な責務分離と機能境界に基づく水平分割により、一人開発における保守性と理解しやすさを確保する。

<!-- PREMISE_END: backend-architecture-style -->

## 論理

前提制約から、Container レベルの実装契約を具体化するには4つの観点が必要である。

### レイヤー構成が必要な理由

レイヤードアーキテクチャを採用することは決まっているが、具体的なレイヤー構成(Presentation層、Application層、Domain層、Infrastructure層等)が定義されていない。階層的な責務分離を実現するには、各レイヤーの責務と依存関係を明確化する必要がある。

### モジュール/パッケージ構造が必要な理由

レイヤードアーキテクチャと機能境界に基づく水平分割を実現するには、コードの物理的な配置を決定する必要がある。レイヤーと機能境界をディレクトリ構造でどう表現するかにより、保守性と理解しやすさが大きく変わる。

### 依存性注入の方針が必要な理由

レイヤードアーキテクチャでは層間の依存関係制御が重要である。FastAPI の依存性注入機構をどう活用するか、各レイヤー間のインターフェースをどう定義するかを決定する必要がある。依存性注入の方針がテスト戦略にも影響を与える。

### テスト構成が必要な理由

不足技術要素にトランザクション境界検証が挙げられている。pytest + 各種プラグインを使用するが、依存性注入方針を踏まえた上で、テストファイルの配置方針とレイヤーごとのテスト戦略を定義する必要がある。

## ディレクトリ構成

実装契約の詳細は以下のファイルで定義する。

- [レイヤー構成](01-layer-structure.md)
- [モジュール/パッケージ構造](02-module-structure.md)
- [依存性注入方針](03-dependency-injection.md)
- [テスト構成](04-test-configuration.md)

## 結論

Container レベルでのバックエンド実装契約を、レイヤー構成・モジュール構造・依存性注入・テストの4つの観点から定義する。
