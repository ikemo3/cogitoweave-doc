# Process View

## 1. サービス間プロセス設計フェーズ

### 1.1. サービス境界設計

<!-- REFERENCE_BEGIN: service-boundaries-decision -->

技術的観点からの最適解は**3 サービス完全分離**となる：

- **コア知識管理サービス**: 安定した CRUD 処理を独立プロセスで実行し、長期安定リリースサイクルで運用
- **LLM 統合サービス**: 外部 API 依存を独立プロセスで分離し、技術進歩に応じた中期リリースサイクルで運用
- **コンテンツ取得サービス**: Web スクレイピングを独立プロセスで分離し、サイト変更に応じた短期リリースサイクルで運用

この構成により実行時の責務分離とリリースサイクルの最適化を両立し、各サービスの独立性を確保できる。

<!-- REFERENCE_END: service-boundaries-decision -->

### 1.2. サービス間協調

<!-- REFERENCE_BEGIN: service-coordination-pattern -->

- **フロントエンド直接呼び出し**: フロントエンドから各サービスを直接呼び出す。
- **一方向依存**: フロントエンドからコンテンツ取得サービスと LLM 統合サービスへの依存のみ存在し、サービス間の相互依存は発生しない。
- **タイムアウトつき同期通信**: フロントエンドから各サービスへの通信はタイムアウトつき同期通信で行う。

<!-- REFERENCE_END: service-coordination-pattern -->

### 1.3. データ整合性設計

<!-- REFERENCE_BEGIN: data-consistency-strategy -->

- **単一データストア責務**: コア知識管理サービスのみがデータ永続化を担当する。
- **ステートレスサービス分離**: LLM 統合サービスとコンテンツ取得サービスは外部データ取得のみを担当し、データを永続化しない。
- **一方向データフロー**: 「外部取得 → フロントエンド統合 → コア保存」の流れに限定する。

<!-- REFERENCE_END: data-consistency-strategy -->

### 1.4. 分散通信設計

<!-- REFERENCE_BEGIN: distributed-communication-design -->

- **HTTP API 直接通信**: フロントエンドから 3 サービスへの直接 HTTP/HTTPS 通信を行う。
- **JSON データフォーマット**: GET/POST による CQS ベースの API 設計で保守しやすい通信を実現する。
- **サービス特性ごとのタイムアウト設定**: 各サービスの処理特性に応じた段階的設定で応答時間管理を行う。
- **HTTP ステータスコードエラーハンドリング**: 4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、サービス特性ごとのリトライ戦略により障害処理を行う。
- **最小限セキュリティ設計**: HTTPS 通信と CORS 設定による基本セキュリティを確保し、認証認可機能は除外する。

<!-- REFERENCE_END: distributed-communication-design -->

### 1.5. 耐障害性設計

<!-- REFERENCE_BEGIN: fault-tolerance-strategy -->

- **データ保護を最優先**: 定期バックアップとバックアップ検証により、概念・文献メモ・関係性データの消失を絶対に防止する。
- **部分機能の継続**: コア知識管理機能を中心とした基本機能の継続動作により、外部 API 障害時でも知識体系の閲覧・編集・保存を維持する。
- **手動復旧を基本**: 自動復旧機構の複雑さを回避し、明確な手動復旧手順と充実したエラー情報により個人での障害対応を支援する。
- **明確なエラー伝達**: 障害種別・影響範囲・対応手順を分かりやすく表示し、開発者自身の技術的判断を支援する。

<!-- REFERENCE_END: fault-tolerance-strategy -->

### 1.6. スケーリング設計

<!-- REFERENCE_BEGIN: scaling-strategy -->

- **単一サーバー構成**: 水平スケーリングの複雑さを回避し、必要に応じた垂直スケーリングにより性能向上を図る。
- **数万件規模への対応**: 概念・文献メモ・関係性データを含めて数万件規模まで対応し、現代の一般的なサーバーで十分な性能を実現する。
- **シンプル運用を優先**: 複雑なスケーリング機構や最適化は実装せず、理解しやすく保守しやすい構成を維持する。

<!-- REFERENCE_END: scaling-strategy -->

### 1.7. トレーサビリティ設計

<!-- REFERENCE_BEGIN: traceability-strategy -->

- **エラートラッキングとシステム監視を分離**: エラー情報の詳細追跡とシステム全体の稼働監視を分離し、既存インフラとの統合を優先する。
- **フロントエンド起点の一括トレーシング**: CSR アーキテクチャを活用したクライアントサイド監視と 3 つのバックエンドサービスとの統合により、システム全体の動作を把握する。
- **必要最小限の監視項目**: 障害検知・エラー把握・パフォーマンス監視に絞り込み、複雑なメトリクスや分析機能は除外する。

<!-- REFERENCE_END: traceability-strategy -->

### 1.8. システムテスト戦略

<!-- REFERENCE_BEGIN: system-test-strategy -->

- **CI 統合疎通テスト**: フロントエンドから 3 サービスへの基本疎通確認のみを CI 環境で実行する。
- **外部 API 依存をモック**: バックエンドサービス内でモック実装によりダミーデータを返却して検証する。
- **バックエンド実起動**: フロントエンドからの HTTP 通信を受け付けるため、フロントエンド側でのモック機能は不要となる。
- **正常系とセキュリティをカバー**: エラーハンドリングや複雑な E2E シナリオは単体テストレベルで対応済みとして除外する。
- **CI 失敗時の迅速復旧**: PR マージ停止、修正または revert による迅速復旧を基本とする。

<!-- REFERENCE_END: system-test-strategy -->

## 2. サービス内プロセス設計フェーズ

### 2.1. リクエスト処理設計

<!-- REFERENCE_BEGIN: request-processing-design -->

- **同期処理ベース**: 基本的に同期処理でシンプルな処理フローを実現し、複雑な業務処理は 1 トランザクション内で完結させる。
- **ログレベル設定**: 開発者対応の緊急度に応じたログレベル（ERROR=即座対応、WARN=計画的改善、INFO=動作確認、DEBUG=開発詳細）を採用し、ユーザーには理解しやすいエラーメッセージのみを提供する。
- **トランザクション分離**: データベース操作のみを対象とし、外部 API 呼び出しは分離する。
- **リクエスト検証**: 型チェック、範囲チェック、形式チェックを含む定型的な検証を実施し、ビジネスロジック検証は別レイヤーで処理する。
- **統一タイムアウト**: 全 API に 10 秒の統一タイムアウトを設定し、外部 API エラー時はフロントエンド側リトライで対応する。
- **性能最適化**: N+1 問題対策とクエリ最適化により性能要件を満たす。

<!-- REFERENCE_END: request-processing-design -->

### 2.2. バッチ処理設計

<!-- REFERENCE_BEGIN: batch-processing-design -->

- **深夜単発バックアップ**: 日次データバックアップを深夜時間帯に単一バッチとして実行し、全データの完全バックアップを取得する。
- **既存通知との連携**: 既存のバックアップ通知仕組みと連携し、失敗時のメール通知により迅速な障害対応を支援する。
- **シンプルなスケジューリング**: 複雑なスケジューラーや並列処理は実装せず、確実な実行を基本とする。
- **データ整合性の確保**: バックアップ実行時点での一貫性を確保し、実行中のユーザーアクセスは停止しない前提で設計する。

<!-- REFERENCE_END: batch-processing-design -->

### 2.3. トランザクション設計

<!-- REFERENCE_BEGIN: transaction-design -->

- **トランザクション境界**: 1 つの API リクエスト内で関連するデータ更新を 1 つのトランザクションで完結させ、部分失敗時は全てロールバックする原子性を確保する。
- **外部 API 分離**: 外部 API 呼び出しはトランザクション外で処理し、データベース操作のみをトランザクション境界とする。
- **READ_COMMITTED 分離レベル**: ギャップロック・ネクストキーロックによるデッドロック危険性を回避する。
- **テーブルアクセス順序統一**: デッドロック発生を予防し、万一発生した場合は例外処理でエラーレスポンスを提供する。
- **データベース制約活用**: データベース制約による整合性管理を活用し、シンプルで理解しやすいトランザクション制御を実現する。

<!-- REFERENCE_END: transaction-design -->

### 2.4. セキュリティ設計

<!-- REFERENCE_BEGIN: security-design -->

- **認証・認可なし**: 個人環境前提により実装せず、シンプルな構成を維持する。
- **セキュリティヘッダー設定**: CSP、X-Frame-Options、X-Content-Type-Options、X-XSS-Protection により基本的なブラウザレベル防御を確立する。
- **HSTS 設定除外**: 開発・テスト環境への支障を避けるため除外する。
- **多層防御実装**: リクエストレイヤーでの入力バリデーション、データアクセスレイヤーでの SQL インジェクション対策、レスポンスレイヤーでの XSS 対策を実装する。
- **個人用途最適化**: Rate Limiting は個人用途により不要とし、セキュリティログも別レイヤー処理として除外する。
- **法的要件遵守**: LLM API 利用規約遵守により、法的要件を満たしたセキュリティ体制を実現する。

<!-- REFERENCE_END: security-design -->

### 2.5. バックエンドパフォーマンス設計

<!-- REFERENCE_BEGIN: backend-performance-design -->

- **応答時間制約**: API 呼び出し 600ms 以内という制約を満たすため、N+1 問題の対策とクエリの最適化を実装する。
- **最小限の最適化**: 複雑なキャッシュ層や分散処理は除外し、必要に応じたデータベースインデックスの設定による最小限の最適化を行う。
- **単一サーバー構成**: 数万件規模のデータに対応することにより、個人用途に十分な性能を確保する。
- **垂直スケーリング**: 性能が劣化した場合はサーバースペックの向上による垂直スケーリングで対応する。
- **シンプルな構成維持**: 複雑な最適化機構は保守性制約により実装せず、理解しやすい構成で長期安定運用を実現する。

<!-- REFERENCE_END: backend-performance-design -->

### 2.6. フロントエンドパフォーマンス設計

<!-- REFERENCE_BEGIN: frontend-performance-design -->

- **初回起動時**: HTML → JavaScript → DOM → レンダリング の順次実行を行う。
- **概念ページ遷移時**: 最小限の状態のみ保持し、大部分は再構築する。
- **エラー時**: シンプルなエラー画面を表示する。
- **段階的改善戦略**: 制約達成が困難な場合のみ段階的改善を追加する。
- **メモリ管理戦略**: メモリ問題が発生した場合はブラウザリロードで解決する。

<!-- REFERENCE_END: frontend-performance-design -->

### 2.7. 監視設計

<!-- REFERENCE_BEGIN: monitoring-design -->

- **サービス特性別監視**: コア知識管理サービスはデータ整合性と応答時間を重視し、LLM 統合サービスは外部 API 依存性を監視し、コンテンツ取得サービスは取得成功率と構造変更を追跡する。
- **階層的監視項目**: 必須監視項目で基本動作を保証し、性能監視項目で応答時間制約を管理し、運用監視項目で長期的な運用判断を支援する。
- **緊急度分類アラート**: 緊急度分類による適切な通知とアラート抑制による根本原因の明確化により、一人での迅速な障害対応を可能にする。

<!-- REFERENCE_END: monitoring-design -->

### 2.8. サービス内テスト戦略

#### バックエンドテスト戦略決定

<!-- REFERENCE_BEGIN: backend-test-strategy -->

- **サービス特性別テスト**: コア知識管理サービスはデータベース操作とトランザクション境界を検証し、LLM 統合サービスは外部 API の契約テストと異常ケース（タイムアウト、エラーレスポンス）対応を実装し、コンテンツ取得サービスは構造変更への適応性を検証する。
- **バックエンドテスト環境**: インメモリ SQLite を使用した高速なテスト実行とテスト毎のクリーンな状態確保、HTTP 通信レベルでの外部 API モック化による安定したテスト実行を実現する。

<!-- REFERENCE_END: backend-test-strategy -->

#### フロントエンドテスト戦略決定

<!-- REFERENCE_BEGIN: frontend-test-strategy -->

- **フロントエンドユニットテスト**: ユーティリティ関数やビジネスロジック関数の正確性を検証し、データ変換・バリデーション・計算処理等の純粋関数の動作を検証する。
- **フロントエンドコンポーネントテスト**: 個別のコンポーネントの動作と表示の正確性を検証し、プロパティによる表示変化・イベントハンドリング・内部状態管理を検証する。
- **フロントエンド統合テスト**: 複数のコンポーネント間の連携を検証し、状態管理・画面遷移・ルーティング・イベント処理の統合動作を検証する。
- **フロントエンドテスト環境**: ユニットテスト用の軽量実行環境・コンポーネントテスト用の DOM 環境・統合テスト用のルーティング状態管理環境を提供し、バックエンド API 依存をモック化する。

<!-- REFERENCE_END: frontend-test-strategy -->

#### API 契約テスト戦略決定

<!-- REFERENCE_BEGIN: api-contract-test-strategy -->

- **フロントエンド・バックエンド間 API 契約**: リクエスト・レスポンス仕様を明文化し、インターフェース契約として文書化する。バックエンド側での API 仕様準拠検証とフロントエンド側での TypeScript 型定義による契約検証により、API 仕様変更の早期検知を実現する。

<!-- REFERENCE_END: api-contract-test-strategy -->
