---
doc_type: "unknown"
status: "draft"
depends:
  contracts: []
  produces: []
---

# はじめに

このファイルは、プロジェクトで用いる**ドキュメントの構成ポリシー**と、その背景となる考え方を説明します。

## アジャイル宣言と comprehensive documentation

アジャイル宣言では「包括的なドキュメントよりも動くソフトウェアを」と謳われていますが、本ドキュメントは、生成 AI によって情報の生成・整理コストが低下した現在、あえて **comprehensive documentation（包括的ドキュメント）** を試みる方針を述べるものです。

これは実験的な試みであり、ドキュメント主導の古い間違ったやり方を肯定するものはありません。あくまで GitLab のようなリモート組織や生成 AI によってドキュメントのコストが軽減しかつエージェントによるコーディングの重要性が増した結果としてプロダクト開発の新しい形を模索する試みです。繰り返しますが、1980 年代のドキュメント主導の古い間違ったやり方を肯定するものはありません。

## ドキュメントのタイプ

ドキュメントは大きく次の 3 種に分類します。

- **個別タイプ**：単体で完結する論理展開をもつもの
  - 前提 → 論理 → 結論（純粋関数的な型）
  - 前提 → 調査 → 論理 → 結論（外部 I/O を含む型）
- **統合型タイプ**：分解した要素を再び合成／統合して全体をまとめるもの
  - 網羅分割: `pattern-comprehensive`
  - 分割合成: `pattern-composite`
- **並列型タイプ**：分解した要素をそのまま並列で保持・管理するもの
  - 直交分割: `pattern-parallel`
- **段階型タイプ**：段階的なプロセスにより最終成果を構築するもの
  - 段階的詳細化：要素を段階的に詳細化して設計を構築
  - 解空間制限：制約を段階的に追加し、選択肢を絞り込み

それぞれ次の `doc_type` を持ちます。

- **個別タイプ**
  - 前提 → 論理 → 結論（純粋関数的な型）: `pattern-logic`
  - 前提 → 調査 → 論理 → 結論（外部 I/O を含む型）: `pattern-research`
  - 段階的リフレーミングによる創造（reframing 型）: `pattern-reframing`
  - 責務から実装への詳細化（UI 要素型）: `pattern-ui`
- **統合型タイプ**：分解した要素を再び合成／統合して全体をまとめるもの
  - 網羅分割: `pattern-comprehensive`
  - 分割合成: `pattern-composite`
- **並列型タイプ**：分解した要素をそのまま並列で保持・管理するもの
  - 直交分割: `pattern-parallel`
- **段階型タイプ**：段階的なプロセスにより最終成果を構築するもの
  - 段階的詳細化: `pattern-elaboration`
  - 解空間制限: `pattern-step`

## 個別タイプ

分解された要素は、次の 2 つの個別パターンに還元できます。

### 1. 前提 → 論理 → 結論（純粋関数的な型）

副作用のない関数のように、与えた前提と知識から結論が導かれる型です。時間経過の影響を受けにくい安定した論証に向きます。

```mermaid
flowchart LR
A[前提] --> B[論理]
B --> C[結論]
```

**構成**：

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 前提
- 論理
- 結論

### 2. 前提 → 調査 → 論理 → 結論（外部 I/O を含む型）

技術選定のように、途中で情報収集や検証を含む型です。外部環境の変化に応じて結論も更新されます。

```mermaid
flowchart LR
A[前提] --> I[調査 / 情報収集]
I --> B[論理]
B --> C[結論]
```

**構成**：

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 前提
- 調査
- 論理
- 結論

### 3. 段階的リフレーミングによる創造（reframing 型）

認知的リフレーミング関手の連続適用により、体験から理想解決策まで段階的に導出する型です。圏論的には「商構造による解空間の段階的収束」として表現されます。

```mermaid
flowchart LR
A[入力対象] --> B[処理フロー]
B --> C[リフレーミングプロセス]
C --> D[出力対象]
D --> E[次段階の入力対象]
```

**構成**：

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 入力対象
- 処理フロー: mermaid で流れを書きます(後述)
- リフレーミングプロセス
- 出力対象

**適用例**：

- 体験リフレーミング（個別体験 → 問題概念）
- 問題リフレーミング（課題 → 境界条件）
- 制約リフレーミング（制約 → ビジョン）
- 理想リフレーミング（ビジョン → アプローチ）
- 手法リフレーミング（アプローチ → 具体体験）

### 4. 責務から実装への詳細化（UI 要素型）

抽象的な責務定義から具体的な実装仕様への写像による変換を行う型です。圏論的には「詳細化関手による構造保存変換」として表現されます。関手の適用により、抽象圏の対象（責務）が具体圏の対象（実装仕様）に写され、その際に本質的な構造が保存されます。

```mermaid
flowchart LR
A[責務定義<br/>抽象レベル] --> F[詳細化関手<br/>F_detail]
F --> B[実装仕様<br/>具体レベル]
B --> C[データフロー]
B --> D[入出力仕様]
B --> E[処理詳細]
```

**構成**：

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 責務
- 責務から仕様への詳細化
- データフロー
- 入力
- 処理
- 出力
- 備考

**圏論的解釈**：

- **抽象圏**: 責務や機能要求の圏。対象は「何をするか」の抽象定義
- **具体圏**: 実装仕様の圏。対象は「どうやるか」の具体定義
- **詳細化関手**: 抽象圏から具体圏への関手。構造保存性により本質的な責務が実装に正しく反映される
- **自然変換**: 異なる UI 要素間での詳細化プロセスの一貫性を保証

## 統合型タイプ

### 統合型タイプの分解

まず論理づけのために対象を分解します。分解には網羅性を重視する方式と独立性を重視する方式の 2 つがありますが、多くの場面では網羅性を優先します。網羅性を取る場合は、

- 根拠（参照・基準・判断理由）を明記する
- 可能なら**MECE**を目指す
- IEEE など外部の標準・分類の採用を検討する

といった原則に従います。

### 統合型タイプの合成・統合

分解後は、要素の結論を合成・統合します。手順は次のとおりです。

1. 各要素から**結論のみ**を抜き出す（後述のマーカーを用いる）。
2. 結論をまとめ、重複・冗長を整理し、必要に応じて分類・並べ替え・縮約を行う。

> 重要な運用ルール：
>
> - 1 ステップで 1 操作のみ行う。例：分類と重複削除を同時に行わない。ワーキングメモリの消費と認知負荷を抑えるためです。
> - 省略は明示的に行う。情報を落とす場合は、必ず 1 ステップを割き、根拠と差分を残します（勝手に省略しない）。

### 網羅分割の構成

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 目次
- 概要
- 処理フロー: mermaid で流れを書きます(後述)
- 網羅分割: なぜこの分割方法を選んだか、なぜ網羅しているかの根拠を記載してください。
- 並列処理: 子の Markdown 文書のリンクの説明とともに、結論を抜き出してください。
- 合成処理: 結論を基底文書へ継承するためにステップバイステップで整理してください。

#### 直交分割の構成

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 目次: ページ内リンク形式で各セクションへのリンクを記載してください。
- 概要
- 処理フロー: mermaid で流れを書きます(後述)
- 直交分割: なぜ直交なのかの根拠を記載してください。
- 並列関係ファイル: 直交要素への個別リンクと各要素の概要を記載してください。

#### 分割合成の構成

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 目次
- 概要
- 処理フロー: mermaid で流れを書きます(後述)
- 独立分割: なぜ分割できるのかの根拠を記載してください。
- 並列処理: 子の Markdown 文書のリンクの説明とともに、結論を抜き出してください。
- 合成処理: 結論を基底文書へ継承するためにステップバイステップで整理してください。

## 段階型タイプ

段階的なプロセスにより最終成果を構築する型です。段階的詳細化では要素を段階的に詳細化して設計を構築し、解空間制限では不確実な要件や広すぎる選択肢を段階的に狭めていきます。

### 段階的詳細化の構成

段階的詳細化は次の見出し構成に従います。設計の異なる観点を段階的に詳細化し、前のステップの結果が次のステップの前提となります。

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 目次
- 概要
- 処理フロー: mermaid で流れを書きます(後述)
- 段階的詳細化: なぜこの詳細化順序を選んだかの根拠を記載してください。
- 直列処理: ステップ 1 → ステップ 2 → ... の順序で、各ステップは子の Markdown 文書で作られます。前のステップの結果が次のステップの前提となります。
- 統合処理: 各ステップの結果を統合し、基底文書への継承のために整理してください。

### 解空間制限の構成

解空間制限は次の見出し構成に従います。ステップ 1〜n は有向非巡回グラフであればよく、直線的である必要はありません。

> **注**：以下の見出しは**そのまま**使用してください。リンタでチェックされます。

- 目次
- 概要
- 処理フロー: mermaid で流れを書きます(後述)
- ステップ 1: まず解空間を制限するためのステップを 1 つ取り上げます。そのステップは子の Markdown 文書で作られます。
- ステップ 2: ステップ 1 の結果を元に、次のステップを組み立てます。同様に子の Markdown 文書で作られます。
- ステップ 3...ステップ n: 同様に進めます。

## マーカー仕様

ドキュメント間での情報継承や統合作業を保証するため、以下の 3 種類のマーカーを使用します。

### FOUNDATION マーカー（結論）

結論として基底文書に継承する内容を示します。

#### FOUNDATION マーカー用途

- **結論の継承**: 個別・統合・段階型すべてのタイプで結論を基底文書に継承
- **新規定義**: このファイルで新たに定義・生産する契約内容
- **基底統合**: Why 系 →19-why-foundation.md、What 系 →24-what-foundation.md

#### FOUNDATION マーカー記法

```markdown
<!-- FOUNDATION_BEGIN: example -->

（結論として継承する内容）

<!-- FOUNDATION_END: example -->
```

### PREMISE マーカー（前提）

前提として利用する契約内容を示します。

#### PREMISE マーカー用途

- **前提の取り込み**: 他の文書で定義された契約を前提として利用
- **論理的基盤**: 推論の出発点となる前提条件
- **依存関係**: 基底文書からの前提継承や他文書への依存

#### PREMISE マーカー記法

```markdown
<!-- PREMISE_BEGIN: example -->

（前提として利用する内容）

<!-- PREMISE_END: example -->
```

### CONCLUSION マーカー（結論・詳細版）

結論として定義するが、基底文書には継承しない詳細な内容を示します。

#### CONCLUSION マーカー用途

- **完全性チェック**: バリデーションで結論の完全性を保証
- **詳細実装**: 実装レベルの詳細な結論を定義
- **基底継承なし**: 基底文書には継承せず、整合性チェックのみ実行

#### CONCLUSION マーカー記法

```markdown
<!-- CONCLUSION_BEGIN: example -->

（結論として定義するが基底文書継承しない内容）

<!-- CONCLUSION_END: example -->
```

### REFERENCE マーカー（参照）

説明や例示のための引用・参照を示します。

#### REFERENCE マーカー用途

- **引用・参照**: 説明や例示のための契約内容の引用
- **統合・まとめ**: 複数契約をまとめる際の参照
- **新規生産しない**: 内容の一致チェックは行うが、基底文書には継承しない

#### REFERENCE マーカー記法

```markdown
<!-- REFERENCE_BEGIN: example -->

（参照・引用する内容）

<!-- REFERENCE_END: example -->
```

### 共通ルール

- マーカー名は任意の名前を指定可能
- マーカーで囲んだ本文は、見出しレベル（行頭の `#`）を除き**完全一致**が必要
- 一致の判定は空白や記号も含む
- 同一マーカー名を持つ内容は、すべてのファイルで**一字一句同じ**でなければならない

## マーカーの取り扱い禁則

### FOUNDATION マーカーの移動・削除は絶対禁止

```markdown
<!-- FOUNDATION_BEGIN: example-id -->

重要な情報内容

<!-- FOUNDATION_END: example-id -->
```

**重要**: FOUNDATION マーカーで囲まれた内容の移動・削除は絶対に禁止。理由:

1. **情報継承の生命線**: 結論を基底文書にそのまま継承するための技術的仕組み
2. **完全複製原則**: 内容は一字一句「そのまま」持っていく。編集・要約・改変は一切禁止
3. **整合性保証**: 同一マーカー ID を持つ全ファイルで内容が完全一致していることが前提

### PREMISE・REFERENCE マーカーも同様の制約

**前提と参照の整合性**: PREMISE・REFERENCE マーカーも同一マーカー ID で内容完全一致が必要。理由:

1. **論理的一貫性**: 前提が変われば結論も変わる可能性があるため
2. **参照の正確性**: 引用・参照内容の正確性を技術的に保証するため

### 許可される操作

**見出しレベル調整のみ許可**: 親ディレクトリに継承する際、階層に応じた見出しレベル調整は可能

```markdown
<!-- 子ファイル -->

### 予算制約の受容

<!-- 親ファイル -->

##### 予算制約の受容
```

### 禁止される操作

- マーカー内容の移動
- マーカー内容の削除
- マーカー内容の編集・要約・改変
- マーカー ID の変更
- マーカーの部分的な抜粋

違反すると設計書体系の情報継承チェーンが破綻し、基底文書での情報欠落・矛盾が発生する。

## 統合方法

### 統合の目的と処理内容

統合は情報を蒸留する多様な目的を持つ。次の 3 つはあくまで例である。

- 優先度付けによる重要度判定
  - 大量の情報から「何が本当に重要か」を判定
  - 必須・任意・除外などのレベル分けで優先順位を明確化
- 重複排除による情報整理
  - 意図が全く同じ重複要素の除去
- 分類・体系化による構造整理
  - 散在する情報を体系的に分類・整理
  - 関係性や依存関係の明確化

### 統合のルール

統合方法は次のルールを適用する。

- 統合作業前にどういう観点で倒すべきかを必ずユーザーと相談して決めること。
- 統合は 1 ステップごとに 1 つの観点で行うこと。その際観点以外のところは一切触れず、そのままコピーすること。
  - 例えば「必須」「任意」「除外」と分類する際は、まずそれぞれが「必須」「任意」「除外」のどれかを決めることが 1 つのステップ。そして決めた分類ごとにまとめるのが次のステップ。この際、分類以外の内容は一切触れず、そのままコピーすること。
- 統合を「要約」「省略」「削除」と誤解して、重要な情報を勝手に落とすことは絶対禁止。必要な場合は必ず 1 つのステップとして独立して行い、観点はユーザーと相談して決めること。

### 禁止事項

- パターン確認なしでの統合作業開始
- マーカー内容の要約・省略・改変
- 処理手順の勝手な変更
- フィルタ処理の省略
