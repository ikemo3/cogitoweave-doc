---
doc_type: "pattern-logic"
status: "draft"
depends:
  contracts:
    - "service-coordination-pattern"
    - "data-consistency-strategy"
    - "api-tech-approach"
    - "api-contract"
    - "frontend-rendering-style"
  produces:
    - "distributed-communication-design"
---

# 分散通信設計

CogitoWeave システムの 3 サービス完全分離構成における具体的な通信設計を行う。REST API によるシンプルな同期通信を確立する。

## 前提

<!-- PREMISE_BEGIN: service-coordination-pattern -->

- **フロントエンド直接呼び出し**: フロントエンドから各サービスを直接呼び出す。
- **一方向依存**: フロントエンドからコンテンツ取得サービスと LLM 統合サービスへの依存のみ存在し、サービス間の相互依存は発生しない。
- **タイムアウトつき同期通信**: フロントエンドから各サービスへの通信はタイムアウトつき同期通信で行う。

<!-- PREMISE_END: service-coordination-pattern -->

<!-- PREMISE_BEGIN: data-consistency-strategy -->

- **単一データストア責務**: コア知識管理サービスのみがデータ永続化を担当する。
- **ステートレスサービス分離**: LLM 統合サービスとコンテンツ取得サービスは外部データ取得のみを担当し、データを永続化しない。
- **一方向データフロー**: 「外部取得 → フロントエンド統合 → コア保存」の流れに限定する。

<!-- PREMISE_END: data-consistency-strategy -->

<!-- PREMISE_BEGIN: api-tech-approach -->

API 技術方針として REST API を採用する。

<!-- PREMISE_END: api-tech-approach -->

<!-- PREMISE_BEGIN: api-contract -->

CogitoWeave の API 契約は以下の 9 つの論理的 API 群で構成される:

### エンティティ操作 API

1. **概念 API**: 作成・読み取り・更新 (削除は優先度低)
2. **文献メモ API**: 作成・読み取り・更新・概念別一覧取得
3. **関係性 API**: 作成・読み取り・更新 (概念間の重複関係許可)
4. **文献 API**: 作成・読み取り (URL・タイトル・引用が必須)

### 検索・発見 API

1. **概念検索 API**: 名前・説明での部分一致検索
2. **質問から概念候補提示 API**: 既存個人概念体系からの検索・発見支援

### 協働・処理 API

1. **LLM 要約生成 API**: 記事内容と概念 ID から観点別要約を生成
2. **記事取得 API**: URL からタイトル・内容を取得
3. **バックアップ API**: Webhook 化による自動実行支援

これらの API により、概念中心の知識体系構築と効率的な知識活用が実現される。

<!-- PREMISE_END: api-contract -->

<!-- PREMISE_BEGIN: frontend-rendering-style -->

CogitoWeave のフロントエンドレンダリングスタイルとして**CSR(Client-Side Rendering)**を採用する。3 画面間の状態共有効率と軽量なコンポーネント指向の特性を活かし、一人での開発における保守性と理解しやすさを確保する。

<!-- PREMISE_END: frontend-rendering-style -->

## 論理

### 問題設定

3 つの独立サービス間で具体的な通信設計を行う必要がある。REST API によるフロントエンド直接呼び出しパターンを実現し、シンプルで保守しやすい通信設計を論理的に導出する。

### 分析

#### サービス別通信パターンの整理

各サービスの通信特性を分析し、最適な設計パターンを導出する。

**コア知識管理サービス**は 9 つの API 群のうち 7 つ(エンティティ操作 API 4 つ + 検索・発見 API 2 つ + バックアップ API)を提供する。標準的な CRUD 操作が中心で、予測可能な応答時間と高い可用性を要求される。データ永続化を担当するため、トランザクション整合性の維持が必要である。

**LLM 統合サービス**は LLM 要約生成 API と質問から概念候補提示 API を提供する。外部 LLM API への依存により応答時間が変動し、API 制限やレート制限の影響を受ける可能性がある。ステートレスな処理のため、障害時のリトライが容易である。

**コンテンツ取得サービス**は記事取得 API を提供する。Web スクレイピングによりネットワーク状況とサイト構造に依存し、処理時間が大きく変動する。ステートレスな処理のため、障害時のリトライが容易である。

#### CSR パフォーマンスバジェット設計

CSR を前提とした具体的なパフォーマンスバジェットを設計し、要件適合性を検証する。

**システム初回起動パフォーマンスバジェット**を以下のように配分する。

- HTML ロード: 300ms 以内
- JavaScript バンドルロード: 800ms 以内
- DOM 構築: 200ms 以内
- 初回 API 呼び出し: 600ms 以内
- レンダリング完了: 300ms 以内
- 合計バジェット: 2200ms（要件 3000ms に対して 800ms の余裕）

**概念ページ読み込みパフォーマンスバジェット**を以下のように配分する。

- JavaScript バンドル: 0ms（ブラウザキャッシュ活用）
- API 呼び出し: 600ms 以内
- レンダリング: 300ms 以内
- 合計バジェット: 900ms（要件 1500ms に対して 600ms の余裕）

**パフォーマンスバジェットの妥当性**により、CSR は設定された要件を十分な余裕をもって達成可能である。初回起動は多少重いが、継続利用での高速性が個人用途の利用パターンに最適化されている。

#### 通信プロトコル設計

REST API の具体的実装方針を決定する。

**HTTP/HTTPS 使用**により標準的な Web 通信プロトコルを採用する。ブラウザからの直接アクセスに必要な CORS 対応が標準でサポートされ、デバッグツールやモニタリングツールが豊富に利用できる。

**JSON データフォーマット**により軽量で解析しやすいデータ交換を実現する。JavaScript との親和性が高く、フロントエンドでの処理が簡素化される。スキーマ定義によるデータ検証も可能である。

**HTTP 通信による CQS ベースの API 設計**を行う。GET による参照系操作と POST による更新系操作の明確な分離により、シンプルで理解しやすい API 設計を実現する。

#### エラーハンドリング設計

各サービスの特性に応じたエラー処理戦略を設計する。

**サービス特性ごとのタイムアウト設定**により応答時間制御を行う。各サービスの処理特性に応じた段階的設定で、適切な応答時間管理を実現する。

**HTTP ステータスコード活用**により統一的なエラー分類を行う。4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、フロントエンドでの適切なエラー処理を支援する。

**サービス特性ごとのリトライ戦略**によりネットワーク障害への対応を行う。安定なサービスは自動リトライ、外部依存サービスは手動リトライも含めた適切なリトライ方式で、一時的障害を処理する。

#### セキュリティ考慮

個人用システムに適した最小限のセキュリティ設計を行う。

**HTTPS 通信**により通信内容の暗号化を行う。プロトタイプ段階でも基本的な通信セキュリティを確保する。

**CORS 設定**によりブラウザからの適切なアクセス制御を行う。開発環境と本番環境での適切なオリジン制限を設定する。

**認証認可は除外**する。個人用途のプロトタイプとして、高度なユーザー認証機能は実装しない。作成者本人のみのアクセス制御は、デプロイメント環境レベルで対応する。

## 結論

<!-- GLOBAL_CONCLUSION_BEGIN: distributed-communication-design -->

- **HTTP API 直接通信**: フロントエンドから 3 サービスへの直接 HTTP/HTTPS 通信を行う。
- **JSON データフォーマット**: GET/POST による CQS ベースの API 設計で保守しやすい通信を実現する。
- **サービス特性ごとのタイムアウト設定**: 各サービスの処理特性に応じた段階的設定で応答時間管理を行う。
- **HTTP ステータスコードエラーハンドリング**: 4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、サービス特性ごとのリトライ戦略により障害処理を行う。
- **最小限セキュリティ設計**: HTTPS 通信と CORS 設定による基本セキュリティを確保し、認証認可機能は除外する。

<!-- GLOBAL_CONCLUSION_END: distributed-communication-design -->

### 論理的根拠

HTTP API 直接通信により、シンプルで理解しやすい通信アーキテクチャを実現し、ブラウザからの直接アクセスに必要な CORS 対応が標準でサポートされる。

JSON データフォーマットにより、JavaScript との親和性が高く、フロントエンドでの処理が簡素化され、スキーマ定義によるデータ検証も可能になる。

サービス特性ごとのタイムアウト設定により、各サービスの処理特性に応じた適切な応答時間管理を実現できる。

HTTP ステータスコードエラーハンドリングにより、4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、フロントエンドでの適切なエラー処理を支援する。

最小限セキュリティ設計により、個人用途のプロトタイプとして適切なレベルのセキュリティを確保し、作成者本人のみのアクセス制御はデプロイメント環境レベルで対応する。
