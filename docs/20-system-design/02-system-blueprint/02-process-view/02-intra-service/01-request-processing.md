---
doc_type: "pattern-logic"
status: "draft"
depends:
  contracts:
    - "domain-model"
    - "development-constraints"
    - "performance-requirements"
  produces:
    - "request-processing-design"
---

# リクエスト処理設計

## 前提

<!-- PREMISE_BEGIN: domain-model -->

CogitoWeave のドメインモデルは薄いドメイン層アプローチを採用する。4 つのエンティティ（概念、文献メモ、関係性、文献）に対して基本的な CRUD 操作と最小限のビジネス制約のみを実装し、複雑なドメインロジックはアプリケーション層に委ねる。データベース制約による整合性管理を活用し、外部 API 処理は分離する。

<!-- PREMISE_END: domain-model -->

<!-- PREMISE_BEGIN: development-constraints -->

- シンプルで理解しやすい構造、一人で管理可能な複雑度に制限する。

<!-- PREMISE_END: development-constraints -->

<!-- PREMISE_BEGIN: performance-requirements -->

- 必須対応
  - システム初回起動: 3 秒以内(アプリケーション全体の初期化)
  - 概念ページ読み込み: 1.5 秒以内(概念間の移動、継続利用での主要操作)
  - 検索結果表示: 1 秒以内(現代の検索体験として期待される応答時間)
  - LLM API 呼び出し: 10 秒以内(生成 AI 市場で期待される処理時間)
  - データベース応答: ミリ秒オーダー(現代のソフトウェアで基本的に期待される応答時間)
- 任意対応
  - 既存ツールを上回るパフォーマンス最適化
- 除外対応
  - 複数ユーザー同時アクセス: 個人ツール市場では期待されない
  - 大規模データ処理: 個人用途範囲を超える性能は不要
  - 企業向け機能: 個人ツール市場では要求されない

<!-- PREMISE_END: performance-requirements -->

## 論理

第一に、サービス内のリクエスト処理フローは同期処理を基本とし、シンプルで理解しやすい構造を採用すべきである。個人開発の制約下では複雑な非同期処理や並行処理制御は保守負荷が高く、一人で管理可能な複雑度を超える。薄いドメイン層アプローチにより複雑なビジネスロジックは存在せず、基本的な CRUD 操作が中心となるため、同期処理による直線的なフローで十分な性能を確保できる。

第二に、トランザクション制御とエラーハンドリングは明確な責務分離が必要である。データベース操作は 1 つの API リクエスト内で完結するトランザクション境界を基本とし、外部 API 呼び出しはトランザクション外で処理する。エラー発生時は開発者対応の緊急度に応じたログレベル設定により、適切な障害対応を支援する。ユーザーには技術詳細やスタックトレースを隠し、理解しやすいエラーメッセージのみを提供する。

第三に、セキュリティとパフォーマンスの両立が必要である。リクエストデータのバリデーションは入力値の型チェック、範囲チェック、形式チェックを含む定型的な検証により、不正データの流入を防止する。ビジネスロジックに依存する検証は別レイヤーで処理し、リクエスト層では技術的制約のみを確認する。概念ページ読み込み 2 秒、検索結果表示 1 秒の制約に対し、N+1 問題対策とクエリ最適化を実装する。全 API リクエストに 10 秒の統一タイムアウトを設定し、外部 API 障害時はフロントエンド側でのリトライ機能により可用性を確保する。

## 結論

<!-- GLOBAL_CONCLUSION_BEGIN: request-processing-design -->

- **同期処理ベース**: 基本的に同期処理でシンプルな処理フローを実現し、複雑な業務処理は 1 トランザクション内で完結させる。
- **ログレベル設定**: 開発者対応の緊急度に応じたログレベル（ERROR=即座対応、WARN=計画的改善、INFO=動作確認、DEBUG=開発詳細）を採用し、ユーザーには理解しやすいエラーメッセージのみを提供する。
- **トランザクション分離**: データベース操作のみを対象とし、外部 API 呼び出しは分離する。
- **リクエスト検証**: 型チェック、範囲チェック、形式チェックを含む定型的な検証を実施し、ビジネスロジック検証は別レイヤーで処理する。
- **統一タイムアウト**: 全 API に 10 秒の統一タイムアウトを設定し、外部 API エラー時はフロントエンド側リトライで対応する。
- **性能最適化**: N+1 問題対策とクエリ最適化により性能要件を満たす。

<!-- GLOBAL_CONCLUSION_END: request-processing-design -->

### 論理的根拠

同期処理ベースにより、個人開発の制約下で複雑な非同期処理や並行処理制御は保守負荷が高く、薄いドメイン層アプローチで基本的な CRUD 操作が中心となるため、直線的なフローで十分な性能を確保できる。

ログレベル設定により、適切な障害対応を支援し、ユーザーには技術詳細を隠して理解しやすいエラーメッセージを提供する。

トランザクション分離により、データベース操作は 1 つの API リクエスト内で完結するトランザクション境界を基本とし、外部 API 呼び出しはトランザクション外で処理することで、明確な責務分離を実現する。

リクエスト検証により、不正データの流入を防止し、ビジネスロジックに依存する検証は別レイヤーで処理することで、技術的制約のみをリクエスト層で確認する。

統一タイムアウトにより、外部 API 障害時の対応を統一し、フロントエンド側でのリトライ機能により可用性を確保する。

性能最適化により、概念ページ読み込み 1.5 秒、検索結果表示 1 秒の制約に対応し、現代のソフトウェアで期待される応答時間を実現する。
