---
doc_type: "pattern-logic"
status: "draft"
depends:
  contracts:
    - "distributed-communication-design"
    - "performance-budget-allocation"
    - "request-processing-design"
    - "scaling-strategy"
    - "development-constraints"
  produces:
    - "backend-performance-design"
---

# バックエンドパフォーマンス設計

## 前提

<!-- PREMISE_BEGIN: distributed-communication-design -->

- **HTTP API 直接通信**: フロントエンドから 3 サービスへの直接 HTTP/HTTPS 通信を行う。
- **JSON データフォーマット**: GET/POST による CQS ベースの API 設計で保守しやすい通信を実現する。
- **サービス特性ごとのタイムアウト設定**: 各サービスの処理特性に応じた段階的設定で応答時間管理を行う。
- **HTTP ステータスコードエラーハンドリング**: 4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、サービス特性ごとのリトライ戦略により障害処理を行う。
- **最小限セキュリティ設計**: HTTPS 通信と CORS 設定による基本セキュリティを確保し、認証認可機能は除外する。

<!-- PREMISE_END: distributed-communication-design -->

<!-- PREMISE_BEGIN: performance-budget-allocation -->

**システム初回起動パフォーマンスバジェット**を以下のように配分する。

- HTML ロード: 300ms 以内
- JavaScript バンドルロード: 800ms 以内
- DOM 構築: 200ms 以内
- 初回 API 呼び出し: 600ms 以内
- レンダリング完了: 300ms 以内
- 合計バジェット: 2200ms（要件 3000ms に対して 800ms の余裕）

**概念ページ読み込みパフォーマンスバジェット**を以下のように配分する。

- JavaScript バンドル: 0ms（ブラウザキャッシュ活用）
- API 呼び出し: 600ms 以内
- レンダリング: 300ms 以内
- 合計バジェット: 900ms（要件 1500ms に対して 600ms の余裕）

<!-- PREMISE_END: performance-budget-allocation -->

<!-- PREMISE_BEGIN: request-processing-design -->

- **同期処理ベース**: 基本的に同期処理でシンプルな処理フローを実現し、複雑な業務処理は 1 トランザクション内で完結させる。
- **ログレベル設定**: 開発者対応の緊急度に応じたログレベル（ERROR=即座対応、WARN=計画的改善、INFO=動作確認、DEBUG=開発詳細）を採用し、ユーザーには理解しやすいエラーメッセージのみを提供する。
- **トランザクション分離**: データベース操作のみを対象とし、外部 API 呼び出しは分離する。
- **リクエスト検証**: 型チェック、範囲チェック、形式チェックを含む定型的な検証を実施し、ビジネスロジック検証は別レイヤーで処理する。
- **統一タイムアウト**: 全 API に 10 秒の統一タイムアウトを設定し、外部 API エラー時はフロントエンド側リトライで対応する。
- **性能最適化**: N+1 問題対策とクエリ最適化により性能要件を満たす。

<!-- PREMISE_END: request-processing-design -->

<!-- PREMISE_BEGIN: scaling-strategy -->

- **単一サーバー構成**: 水平スケーリングの複雑さを回避し、必要に応じた垂直スケーリングにより性能向上を図る。
- **数万件規模への対応**: 概念・文献メモ・関係性データを含めて数万件規模まで対応し、現代の一般的なサーバーで十分な性能を実現する。
- **シンプル運用を優先**: 複雑なスケーリング機構や最適化は実装せず、理解しやすく保守しやすい構成を維持する。

<!-- PREMISE_END: scaling-strategy -->

<!-- PREMISE_BEGIN: development-constraints -->

- シンプルで理解しやすい構造、一人で管理可能な複雑度に制限する。

<!-- PREMISE_END: development-constraints -->

## 論理

第一に、バックエンドパフォーマンス設計では明確な応答時間制約を満たすことが最優先である。概念ページの読み込みは 1.5 秒以内、検索結果の表示は 1 秒以内、LLM API の呼び出しは 10 秒以内という制約は、個人の思考支援ツールとしての実用性を左右する重要な要件となる。これらの制約を満たすため、N+1 問題の対策とクエリの最適化による効率的なデータアクセスが必須である。

第二に、個人用途に特化した性能設計により複雑な最適化を回避すべきである。複数ユーザーの同時アクセスや大規模データ処理は対象外であり、キャッシュ層等の複雑な最適化機構は保守負荷増大のリスクが利益を上回る。単一サーバー構成で数万件規模のデータに対応することにより、シンプルかつ十分な性能を確保する。

第三に、必要に応じた最小限の最適化により実用的な性能を実現すべきである。データベースのインデックスは必要があれば設定し、基本的なクエリ最適化により応答時間制約を満たす。性能が劣化した場合はサーバースペックの向上による垂直スケーリングを基本とし、複雑な水平スケーリングや分散処理は採用しない。

第四に、前提の CSR パフォーマンスバジェットからバックエンド関連の性能予算を抽出してバックエンドパフォーマンスバジェットとして設定すべきである。

**バックエンドパフォーマンスバジェット**により応答時間要件の達成を保証する。

- システム初回起動バジェット
  - 初回 API 呼び出し: 600ms 以内
- 概念ページ読み込みバジェット
  - API 呼び出し: 600ms 以内

## 結論

<!-- GLOBAL_CONCLUSION_BEGIN: backend-performance-design -->

- **応答時間制約**: API 呼び出し 600ms 以内という制約を満たすため、N+1 問題の対策とクエリの最適化を実装する。
- **最小限の最適化**: 複雑なキャッシュ層や分散処理は除外し、必要に応じたデータベースインデックスの設定による最小限の最適化を行う。
- **単一サーバー構成**: 数万件規模のデータに対応することにより、個人用途に十分な性能を確保する。
- **垂直スケーリング**: 性能が劣化した場合はサーバースペックの向上による垂直スケーリングで対応する。
- **シンプルな構成維持**: 複雑な最適化機構は保守性制約により実装せず、理解しやすい構成で長期安定運用を実現する。

<!-- GLOBAL_CONCLUSION_END: backend-performance-design -->

### 論理的根拠

応答時間制約により、概念ページの読み込み 1.5 秒以内、検索結果の表示 1 秒以内、LLM API 呼び出し 10 秒以内という制約は、個人の思考支援ツールとしての実用性を左右する重要な要件となる。

最小限の最適化により、個人用途に特化した性能設計で複雑な最適化を回避し、キャッシュ層等の複雑な最適化機構は保守負荷増大のリスクが利益を上回るため除外する。

単一サーバー構成により、複数ユーザーの同時アクセスや大規模データ処理は対象外であり、シンプルかつ十分な性能を確保する。

垂直スケーリングにより、複雑な水平スケーリングや分散処理は採用せず、実用的な性能を実現する。

シンプルな構成維持により、一人で管理可能な複雑度に制限し、長期にわたる安定運用を実現する。
