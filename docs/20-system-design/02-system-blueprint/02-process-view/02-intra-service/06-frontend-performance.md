---
doc_type: "pattern-choice"
status: "draft"
depends:
  contracts:
    - "distributed-communication-design"
    - "performance-budget-allocation"
    - "development-constraints"
    - "performance-requirements"
    - "device-optimized-interface"
    - "target-platforms"
    - "frontend-rendering-style"
    - "ui-tech-approach"
    - "component-granularity-design"
    - "state-management-responsibilities"
  produces:
    - "frontend-performance-design"
---

# フロントエンドパフォーマンス設計

## 概要

<!-- PREMISE_BEGIN: distributed-communication-design -->

- **HTTP API 直接通信**: フロントエンドから 3 サービスへの直接 HTTP/HTTPS 通信を行う。
- **JSON データフォーマット**: GET/POST による CQS ベースの API 設計で保守しやすい通信を実現する。
- **サービス特性ごとのタイムアウト設定**: 各サービスの処理特性に応じた段階的設定で応答時間管理を行う。
- **HTTP ステータスコードエラーハンドリング**: 4xx 系でクライアントエラー、5xx 系でサーバーエラーを表現し、サービス特性ごとのリトライ戦略により障害処理を行う。
- **最小限セキュリティ設計**: HTTPS 通信と CORS 設定による基本セキュリティを確保し、認証認可機能は除外する。

<!-- PREMISE_END: distributed-communication-design -->

<!-- PREMISE_BEGIN: performance-budget-allocation -->

**システム初回起動パフォーマンスバジェット**を以下のように配分する。

- HTML ロード: 300ms 以内
- JavaScript バンドルロード: 800ms 以内
- DOM 構築: 200ms 以内
- 初回 API 呼び出し: 600ms 以内
- レンダリング完了: 300ms 以内
- 合計バジェット: 2200ms（要件 3000ms に対して 800ms の余裕）

**概念ページ読み込みパフォーマンスバジェット**を以下のように配分する。

- JavaScript バンドル: 0ms（ブラウザキャッシュ活用）
- API 呼び出し: 600ms 以内
- レンダリング: 300ms 以内
- 合計バジェット: 900ms（要件 1500ms に対して 600ms の余裕）

<!-- PREMISE_END: performance-budget-allocation -->

<!-- PREMISE_BEGIN: development-constraints -->

- シンプルで理解しやすい構造、一人で管理可能な複雑度に制限する。

<!-- PREMISE_END: development-constraints -->

<!-- PREMISE_BEGIN: performance-requirements -->

- 必須対応
  - システム初回起動: 3 秒以内(アプリケーション全体の初期化)
  - 概念ページ読み込み: 1.5 秒以内(概念間の移動、継続利用での主要操作)
  - 検索結果表示: 1 秒以内(現代の検索体験として期待される応答時間)
  - LLM API 呼び出し: 10 秒以内(生成 AI 市場で期待される処理時間)
  - データベース応答: ミリ秒オーダー(現代のソフトウェアで基本的に期待される応答時間)
- 任意対応
  - 既存ツールを上回るパフォーマンス最適化
- 除外対応
  - 複数ユーザー同時アクセス: 個人ツール市場では期待されない
  - 大規模データ処理: 個人用途範囲を超える性能は不要
  - 企業向け機能: 個人ツール市場では要求されない

<!-- PREMISE_END: performance-requirements -->

<!-- PREMISE_BEGIN: device-optimized-interface -->

- **Mac 環境**: マルチウィンドウ・複雑レイアウト活用による情報整理専用 UI
- **iPhone 環境**: シンプル・タッチ最適化による情報参照専用 UI
- **レスポンシブ設計**: デバイス切り替え時の文脈継続性確保

<!-- PREMISE_END: device-optimized-interface -->

<!-- PREMISE_BEGIN: target-platforms -->

- 必須対応
  - 情報整理機能: Mac (Chrome) - デスクトップ環境中心
  - 情報参照機能: Mac (Chrome) + iPhone (Safari) - 全環境対応
  - 実行環境: Web 技術による実装、複数デバイス間でのデータ共有を前提
- 任意対応
  - 作成者環境外での動作は妨げないが保証しない
  - Web 技術による実装のため、一般的なモダンブラウザで基本動作は期待できる
- 除外対応
  - ネイティブアプリ開発(iOS・macOS 別実装)
  - ローカルストレージのみによる単一デバイス運用

<!-- PREMISE_END: target-platforms -->

<!-- PREMISE_BEGIN: frontend-rendering-style -->

CogitoWeave のフロントエンドレンダリングスタイルとして**CSR(Client-Side Rendering)**を採用する。3 画面間の状態共有効率と軽量なコンポーネント指向の特性を活かし、一人での開発における保守性と理解しやすさを確保する。

<!-- PREMISE_END: frontend-rendering-style -->

<!-- PREMISE_BEGIN: ui-tech-approach -->

CogitoWeave の UI 技術方針として、Web 技術による柔軟な実装アプローチを採用する。プラットフォーム制約によりネイティブアプリ開発は除外され、マルチデバイス対応とユーザーインタラクション特性を考慮した選択肢から最適解を選択する。

### 除外される技術選択肢

- **ネイティブアプリ**: プラットフォーム制約により除外済み
- **SSG(Static Site Generation)**: 編集機能中心に矛盾し、マルチデバイス共有に適さない
- **ローカルオンリー**: マルチデバイス前提制約に違反

### 許容される技術選択肢

- **レンダリング方式**: CSR、SSR、またはハイブリッドアプローチのいずれも可能である
  - プライベート用途により SEO 要件がないため、CSR の制約がない
  - 初回ロード速度重視により SSR の利点もある
- **アプリケーション構造**: SPA、MPA、または SPA ベース+ページ分割のハイブリッドアプローチのいずれも可能である
  - 作業完結型の操作パターンにより MPA に適合する
  - 効率性重視の継続利用により SPA の利点もある
- **コンポーネント方針**: 軽量コンポーネント指向を基本とし、必要に応じてページ指向も選択可能である
  - UI 要素の再利用性と一貫性確保が必要
  - デザインシステムレベルまでは不要

### 技術方針決定の基準

具体的な技術選択は、Development View において以下の基準で決定する:

- 保守性と理解しやすさの優先
- 一人での管理可能な複雑度
- Mac 環境での情報整理機能と iPhone 環境での情報参照機能の最適化

<!-- PREMISE_END: ui-tech-approach -->

<!-- PREMISE_BEGIN: frontend-rendering-style -->

CogitoWeave のフロントエンドレンダリングスタイルとして**CSR(Client-Side Rendering)**を採用する。3 画面間の状態共有効率と軽量なコンポーネント指向の特性を活かし、一人での開発における保守性と理解しやすさを確保する。

<!-- PREMISE_END: frontend-rendering-style -->

<!-- PREMISE_BEGIN: component-granularity-design -->

CogitoWeave の UI コンポーネント責務として、階層的な粒度設計による軽量なコンポーネント指向アーキテクチャを採用する。

- **最小粒度**: ボタン・入力フィールド・ラベル等の基本 UI 要素レベル
  - 単一責務の原則により、一つの操作または表示に特化する。
- **統合粒度**: カード・パネル・モーダル等の機能単位レベル
  - 複数の基本要素を組み合わせた意味のある機能を提供する。
- **階層アプローチ**: 統合コンポーネント内で基本コンポーネントを組み合わせる
  - 外部からは統合コンポーネントとして使用し、内部実装では基本コンポーネントで構成する。

<!-- PREMISE_END: component-granularity-design -->

<!-- PREMISE_BEGIN: state-management-responsibilities -->

状態管理は 3 層に分離して責務を明確化する。

- **コンポーネント内部状態**: 表示状態・入力値・開閉状態等の局所的な制御
  - コンポーネント固有の UI 状態管理に限定する
- **ページレベル状態**: 選択中概念・検索フィルタ・編集中データ等の複数コンポーネント間共有
  - 状態管理ライブラリを使用してページ内グローバル状態を管理する
- **アプリケーション全体状態**: ユーザー設定・表示設定・大きなコンポーネント間同期データ
  - 永続化データはブラウザの localStorage を使用する
  - ページ境界を越えた大きなコンポーネント間の同期はクライアント側状態管理で対応する

<!-- PREMISE_END: state-management-responsibilities -->

## 選択肢と判断基準

### 判断基準

1. **シンプルさと保守性**: 一人での管理可能な複雑度制限を最優先とする。
2. **制約達成の確実性**: パフォーマンスバジェットの確実な達成を重視する。
3. **理解しやすさ**: 予測可能で デバッグが容易な設計を選択する。
4. **段階的改善可能性**: 基本実装で制約達成できない場合の改善余地を確保する。

## 各選択肢の詳細分析

### 1. 初回起動時の実行時協調パターン

#### 選択肢 A: 順次実行パターン

- HTML → JavaScript → DOM → レンダリング の段階的実行により、予測しやすく理解しやすい処理フローを実現する。
- 各段階の制約(300ms, 800ms, 200ms, 300ms)を順守し、デバッグとトラブルシューティングが容易である。
- シンプルな制御ロジックにより、一人での管理可能な複雑度を維持する。

#### 選択肢 B: 並列実行パターン

- 可能な処理を並列化(JavaScript ロード中に DOM 構築等)により、理論的な高速化の可能性がある。
- 制御ロジックが複雑になり、タイミング制御の難易度が高く、デバッグが困難になる。
- 一人での管理可能な複雑度を超える可能性がある。

#### 選択肢 C: Critical Path 優先パターン

- 最初に必要な機能のみ優先ロードし、段階的機能展開により体感速度向上を図る。
- 部分的利用開始が可能だが、機能の優先順位判定と段階的展開制御が複雑になる。
- 制御ロジックが中程度複雑で、保守負荷が増加する。

### 2. 概念ページ遷移時の状態管理パターン

#### 選択肢 A: フル状態保持パターン

- SPA 内で全状態をメモリ保持し、0ms 遷移の実現が容易である。
- メモリ使用量増加のリスクがあり、長時間利用でのメモリリークの可能性がある。
- 状態管理の複雑度が高く、デバッグが困難になる。

#### 選択肢 B: 選択的状態保持パターン

- 重要な状態のみ保持し、その他は再取得することで、メモリとパフォーマンスのバランスを取る。
- 状態の重要度判定と選択的保持の制御ロジックが中程度複雑になる。
- パフォーマンス予測が困難で、制約達成の確実性が低下する。

#### 選択肢 C: 最小状態保持パターン

- 基本的な状態のみ保持し、大部分は再構築することで、シンプルな制御とメモリ効率を実現する。
- 一部処理の再実行が発生するが、制御ロジックが最もシンプルで理解しやすい。
- メモリ問題が発生した場合はブラウザリロードによる解決を行う方針と整合する。

## 判断基準による評価

### 1. 初回起動時の実行時協調パターンの評価

- **選択肢 A (順次実行)**: シンプル性 ★★★、確実性 ★★★、理解しやすさ ★★★、改善余地 ★★
- **選択肢 B (並列実行)**: シンプル性 ★、確実性 ★、理解しやすさ ★、改善余地 ★★★
- **選択肢 C (Critical Path 優先)**: シンプル性 ★★、確実性 ★★、理解しやすさ ★★、改善余地 ★★★

### 2. 概念ページ遷移時の状態管理パターンの評価

- **選択肢 A (フル状態保持)**: シンプル性 ★、確実性 ★★、理解しやすさ ★、改善余地 ★★
- **選択肢 B (選択的状態保持)**: シンプル性 ★★、確実性 ★、理解しやすさ ★★、改善余地 ★★★
- **選択肢 C (最小状態保持)**: シンプル性 ★★★、確実性 ★★★、理解しやすさ ★★★、改善余地 ★★

## 最終選択と根拠

### 1. 初回起動時の実行時協調パターン: 選択肢 A（順次実行パターン）

順次実行パターンを採用する理由は、シンプルさと保守性を最優先とするためである。HTML → JavaScript → DOM → レンダリング の段階的実行により、予測しやすく理解しやすい処理フローを実現し、一人での管理可能な複雑度を維持する。各段階の制約達成が困難な場合のみ、読み込み中 DOM 構築等の段階的改善を追加する。

### 2. 概念ページ遷移時の状態管理パターン: 選択肢 C（最小状態保持パターン）

最小状態保持パターンを採用する理由は、シンプルさと保守性を最優先とするためである。基本的な状態のみ保持し、大部分は再構築することで、制御ロジックを最もシンプルに保ち、メモリ効率を確保する。メモリ問題が発生した場合はブラウザリロードによる解決を行う方針と整合し、長期運用での安定性を重視する。

### 結論

<!-- GLOBAL_CONCLUSION_BEGIN: frontend-performance-design -->

- **初回起動時**: HTML → JavaScript → DOM → レンダリング の順次実行を行う。
- **概念ページ遷移時**: 最小限の状態のみ保持し、大部分は再構築する。
- **エラー時**: シンプルなエラー画面を表示する。
- **段階的改善戦略**: 制約達成が困難な場合のみ段階的改善を追加する。
- **メモリ管理戦略**: メモリ問題が発生した場合はブラウザリロードで解決する。

<!-- GLOBAL_CONCLUSION_END: frontend-performance-design -->

### 論理的根拠

初回起動時の順次実行により、HTML → JavaScript → DOM → レンダリング の段階的実行で予測しやすく理解しやすい処理フローを実現し、一人での管理可能な複雑度を維持する。

概念ページ遷移時の最小状態保持により、基本的な状態のみ保持し大部分は再構築することで、制御ロジックを最もシンプルに保ち、メモリ効率を確保する。

エラー時のシンプル表示により、複雑なエラーハンドリングを回避し、理解しやすいユーザー体験を提供する。

段階的改善戦略により、基本実装で制約達成が困難な場合のみ改善を追加し、過度な最適化を回避する。

メモリ管理戦略により、メモリ問題発生時はブラウザリロードによる解決を行い、長期運用での安定性を重視する。
