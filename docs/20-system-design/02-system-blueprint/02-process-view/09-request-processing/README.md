---
doc_type: "pattern-logic"
status: "draft"
depends:
  contracts:
    - "domain-model"
    - "development-constraints"
    - "performance-requirements"
  produces:
    - "request-processing-design"
---

# リクエスト処理設計

## 前提

<!-- PREMISE_BEGIN: domain-model -->

CogitoWeave のドメインモデルは薄いドメイン層アプローチを採用する。4 つのエンティティ（概念、文献メモ、関係性、文献）に対して基本的な CRUD 操作と最小限のビジネス制約のみを実装し、複雑なドメインロジックはアプリケーション層に委ねる。データベース制約による整合性管理を活用し、外部 API 処理は分離する。

<!-- PREMISE_END: domain-model -->

<!-- PREMISE_BEGIN: development-constraints -->

- シンプルで理解しやすい構造、一人で管理可能な複雑度に制限する。

<!-- PREMISE_END: development-constraints -->

<!-- PREMISE_BEGIN: performance-requirements -->

- 必須対応
  - 概念ページ読み込み: 2 秒以内(既存ツールレベル)
  - 検索結果表示: 1 秒以内(現代の検索体験期待)
  - LLM API 呼び出し: 10 秒以内(生成 AI 市場期待)
  - データベース応答: ミリ秒オーダー(現代ソフトウェア基本期待)
- 任意対応
  - 既存ツールを上回るパフォーマンス最適化
- 除外対応
  - 複数ユーザー同時アクセス: 個人ツール市場では期待されない
  - 大規模データ処理: 個人用途範囲を超える性能は不要
  - 企業向け機能: 個人ツール市場では要求されない

<!-- PREMISE_END: performance-requirements -->

## 論理

第一に、サービス内のリクエスト処理フローは同期処理を基本とし、シンプルで理解しやすい構造を採用すべきである。個人開発の制約下では複雑な非同期処理や並行処理制御は保守負荷が高く、一人で管理可能な複雑度を超える。薄いドメイン層アプローチにより複雑なビジネスロジックは存在せず、基本的な CRUD 操作が中心となるため、同期処理による直線的なフローで十分な性能を確保できる。

第二に、トランザクション制御とエラーハンドリングは明確な責務分離が必要である。データベース操作は 1 つの API リクエスト内で完結するトランザクション境界を基本とし、外部 API 呼び出しはトランザクション外で処理する。エラー発生時は開発者対応の緊急度に応じたログレベル設定により、適切な障害対応を支援する。ユーザーには技術詳細やスタックトレースを隠し、理解しやすいエラーメッセージのみを提供する。

第三に、セキュリティとパフォーマンスの両立が必要である。リクエストデータのバリデーションは入力値の型チェック、範囲チェック、形式チェックを含む定型的な検証により、不正データの流入を防止する。ビジネスロジックに依存する検証は別レイヤーで処理し、リクエスト層では技術的制約のみを確認する。概念ページ読み込み 2 秒、検索結果表示 1 秒の制約に対し、N+1 問題対策とクエリ最適化を実装する。全 API リクエストに 10 秒の統一タイムアウトを設定し、外部 API 障害時はフロントエンド側でのリトライ機能により可用性を確保する。

## 結論

<!-- GLOBAL_CONCLUSION_BEGIN: request-processing-design -->

CogitoWeave のリクエスト処理設計として、**同期処理ベース・トランザクション分離型**アプローチを採用する。

基本的に同期処理でシンプルな処理フローを実現し、複雑な業務処理は 1 トランザクション内で完結させる。エラーハンドリングは開発者対応の緊急度に応じたログレベル（ERROR=即座対応、WARN=計画的改善、INFO=動作確認、DEBUG=開発詳細）を採用し、ユーザーには理解しやすいエラーメッセージのみを提供する。

トランザクション制御はデータベース操作のみを対象とし、外部 API 呼び出しは分離する。リクエストデータのバリデーションは型チェック、範囲チェック、形式チェックを含む定型的な検証を実施し、ビジネスロジックに依存する検証は別レイヤーで処理する。全 API に 10 秒の統一タイムアウトを設定し、外部 API エラー時はフロントエンド側リトライで対応する。N+1 問題対策とクエリ最適化により性能要件を満たす。

<!-- GLOBAL_CONCLUSION_END: request-processing-design -->
