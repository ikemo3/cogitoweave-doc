---
doc_type: "pattern-logic"
status: "draft"
depends:
  contracts:
    - "ui-tech-approach"
    - "efficiency-focused-operation"
  produces:
    - "component-granularity-design"
    - "state-management-responsibilities"
    - "data-flow-design"
    - "device-adaptation-approach"
---

# UI コンポーネント責務

## 前提

<!-- PREMISE_BEGIN: ui-tech-approach -->

CogitoWeave の UI 技術方針として、Web 技術による柔軟な実装アプローチを採用する。プラットフォーム制約によりネイティブアプリ開発は除外され、マルチデバイス対応とユーザーインタラクション特性を考慮した選択肢から最適解を選択する。

### 除外される技術選択肢

- **ネイティブアプリ**: プラットフォーム制約により除外済み
- **SSG(Static Site Generation)**: 編集機能中心に矛盾し、マルチデバイス共有に適さない
- **ローカルオンリー**: マルチデバイス前提制約に違反

### 許容される技術選択肢

- **レンダリング方式**: CSR、SSR、またはハイブリッドアプローチのいずれも可能である
  - プライベート用途により SEO 要件がないため、CSR の制約がない
  - 初回ロード速度重視により SSR の利点もある
- **アプリケーション構造**: SPA、MPA、または SPA ベース+ページ分割のハイブリッドアプローチのいずれも可能である
  - 作業完結型の操作パターンにより MPA に適合する
  - 効率性重視の継続利用により SPA の利点もある
- **コンポーネント方針**: 軽量コンポーネント指向を基本とし、必要に応じてページ指向も選択可能である
  - UI 要素の再利用性と一貫性確保が必要
  - デザインシステムレベルまでは不要

### 技術方針決定の基準

具体的な技術選択は、Development View において以下の基準で決定する:

- 保守性と理解しやすさの優先
- 一人での管理可能な複雑度
- Mac 環境での情報整理機能と iPhone 環境での情報参照機能の最適化

<!-- PREMISE_END: ui-tech-approach -->

#### 効率性重視の操作設計

<!-- PREMISE_BEGIN: efficiency-focused-operation -->

- **マウス操作中心**: 文字入力以外はマウス操作を基本とした直感的インターフェース
- **GUI 重視**: 複雑な操作もクリック・ドラッグ等の視覚的操作で完結
- **操作学習前提**: 初回直感性より継続利用での効率性を重視

<!-- PREMISE_END: efficiency-focused-operation -->

## 論理

CogitoWeave の UI コンポーネント設計において、軽量コンポーネント指向と効率性重視の操作設計を両立させる責務分担を定義する。コンポーネントの粒度、状態管理の責務、データフローの設計が核心となる。

### コンポーネント粒度の決定

UI コンポーネントは再利用性と保守性のバランスを考慮し、階層的な粒度設計を採用する。最小粒度はボタン・入力フィールドレベルとし、統合粒度はカード・パネルレベルまでとする。ページ全体をコンポーネント化することは複雑度が高すぎるため避ける。

### 状態管理責務の分離

状態管理は 3 層に分離して責務を明確化する。コンポーネント内部状態は表示制御に特化し、ページレベル状態は複数コンポーネント間の協調に使用し、アプリケーション全体状態は永続化データと大きなコンポーネント間同期データに使用する。サーバー側でのリアルタイム同期は実装複雑度が高いため、クライアント側での状態管理を基本とする。

### データフローパターンの統一

コンテナコンポーネントパターンによりデータ取得責務を上位に集約し、props と callback による単方向データフローを基本とする。これにより各コンポーネントの責務を明確化し、保守性を向上させる。

## 結論

<!-- GLOBAL_CONCLUSION_BEGIN: component-granularity-design -->

CogitoWeave の UI コンポーネント責務として、階層的な粒度設計による軽量なコンポーネント指向アーキテクチャを採用する。

- **最小粒度**: ボタン・入力フィールド・ラベル等の基本 UI 要素レベル
  - 単一責務の原則により、一つの操作または表示に特化する。
- **統合粒度**: カード・パネル・モーダル等の機能単位レベル
  - 複数の基本要素を組み合わせた意味のある機能を提供する。
- **階層アプローチ**: 統合コンポーネント内で基本コンポーネントを組み合わせる
  - 外部からは統合コンポーネントとして使用し、内部実装では基本コンポーネントで構成する。

<!-- GLOBAL_CONCLUSION_END: component-granularity-design -->

<!-- GLOBAL_CONCLUSION_BEGIN: state-management-responsibilities -->

状態管理は 3 層に分離して責務を明確化する。

- **コンポーネント内部状態**: 表示状態・入力値・開閉状態等の局所的な制御
  - コンポーネント固有の UI 状態管理に限定する
- **ページレベル状態**: 選択中概念・検索フィルタ・編集中データ等の複数コンポーネント間共有
  - 状態管理ライブラリを使用してページ内グローバル状態を管理する
- **アプリケーション全体状態**: ユーザー設定・表示設定・大きなコンポーネント間同期データ
  - 永続化データはブラウザの localStorage を使用する
  - ページ境界を越えた大きなコンポーネント間の同期はクライアント側状態管理で対応する

<!-- GLOBAL_CONCLUSION_END: state-management-responsibilities -->

<!-- GLOBAL_CONCLUSION_BEGIN: data-flow-design -->

コンテナコンポーネントパターンと単方向データフローによるデータ設計を採用する。

- **コンテナコンポーネントパターン**: データ取得・API 呼び出し責務を上位コンポーネントに集約
  - プレゼンテーショナルコンポーネントは props によるデータ受け取りに特化する
- **単方向データフロー**: props による下方向データ流れと callback による上方向イベント伝播
  - データの流れを予測可能にし、デバッグとテストを容易にする
- **イベント駆動通信**: 子コンポーネントから親コンポーネントへは callback props によるイベント通知
  - 疎結合を保ちながら必要な情報のみを伝達する

<!-- GLOBAL_CONCLUSION_END: data-flow-design -->

<!-- GLOBAL_CONCLUSION_BEGIN: device-adaptation-approach -->

デバイス別対応はコンポーネント共通化とレスポンシブ設計による適応的 UI で実現する。

- **コンポーネント共通化**: 同一コンポーネントをデバイス別に CSS で最適化
  - Mac 環境と iPhone 環境で共通のコンポーネントロジックを使用する
- **レスポンシブ設計**: デバイス別の表示密度と操作方法に応じた適応的 UI
  - 情報整理機能と情報参照機能の違いを CSS レベルで調整する

<!-- GLOBAL_CONCLUSION_END: device-adaptation-approach -->
