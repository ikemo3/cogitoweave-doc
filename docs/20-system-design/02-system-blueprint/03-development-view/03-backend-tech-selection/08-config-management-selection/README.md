---
doc_type: "pattern-choice"
status: "draft"
depends:
  contracts:
    - "language-framework-selection"
    - "platform-constraints"
    - "security-requirements"
  produces:
    - "config-management-tech-selection"
---

# 設定管理技術選択

## 概要

CogitoWeave システムにおける環境変数・設定ファイル管理技術の選択。個人用途、ローカル開発と本番環境のみの構成で、フロントエンド・バックエンド両方を対象とした最適解を決定する。

### 前提

<!-- PREMISE_BEGIN: language-framework-selection -->

Python + FastAPI を採用する。既存スキル活用、技術選択基準「大差ないときは慣れた技術を選ぶ」への適合、疎結合設計による密結合リスク回避により、最適な選択である。

<!-- PREMISE_END: language-framework-selection -->

<!-- PREMISE_BEGIN: platform-constraints -->

1. **Mac 環境制約**: Chrome 上で情報整理機能が完全動作すること
2. **iPhone 環境制約**: Safari 上で情報参照機能が基本動作すること
3. **Web 標準採用基準**: Baseline Newly available を技術選択の判断基準とすること
4. **マルチデバイス前提**: Web 技術による複数デバイス間データ共有を前提とすること

これ以外の基本セキュリティ対策(HTTPS、SQLi/XSS 対策等)、現代 Web 標準性能要件、個人情報保護法等の法規制遵守、個人環境限定によるセキュリティリスク軽減は現代 Web 開発標準に準拠する。

<!-- PREMISE_END: platform-constraints -->

<!-- PREMISE_BEGIN: security-requirements -->

- 必須対応
  - 外部 API 接続時の HTTPS 通信(LLM API・MCP 統合)
  - SQL インジェクション対策・XSS 対策の基本実装
  - 個人情報保護法に基づくプライバシー配慮設計
  - LLM API 利用規約・各種サービス規約の遵守
  - 攻撃対象面の限定(作成者個人環境のみ)によるリスク軽減
- 任意対応
  - 作成者本人のみアクセス可能なアクセス制御
  - 全通信の HTTPS 暗号化
- 除外対応
  - 高度なユーザー認証機能(プロトタイプ段階)
  - データ暗号化(プロトタイプ段階)
  - 詳細なアクセス制御(プロトタイプ段階)

<!-- PREMISE_END: security-requirements -->

## 選択肢と判断基準

ローカル開発と本番環境のみの構成で、フロントエンド・バックエンド両方の設定管理技術を選択する。個人用途でありセキュリティ要件は基本レベル、管理負荷の軽減を最重視する。

### 対象設定項目

- **LLM API 設定**: エンドポイント URL、API キー、モデル指定
- **データベース設定**: 接続文字列、タイムアウト設定
- **外部サービス設定**: 記事取得 API、タイムアウト設定
- **アプリケーション設定**: ログレベル、デバッグモード
- **フロントエンド設定**: API エンドポイント、環境識別

### 環境構成

- **ローカル開発環境**: 開発者の Mac 環境でのテスト・開発用
- **本番環境**: 自宅 Ubuntu サーバーでの実運用環境

### 判断基準

- シンプルさ (優先度最高) - 一人開発における理解しやすさと管理負荷の軽減
- セキュリティ基準適合 - 機密情報保護の基本レベル満足
- 環境分離 - ローカル・本番環境での設定値切り替えの確実性
- フロントエンド対応 - Web 技術での設定管理の自然さ
- 既存技術親和性 - Python + FastAPI エコシステムとの統合性

### 選択肢

- 環境変数 + .env ファイル: シンプルな環境変数管理
- YAML/TOML 設定ファイル: 構造化された設定管理
- Python 設定モジュール: コードベースの設定管理
- 外部設定サービス: クラウド設定管理サービス利用

## 各選択肢の詳細分析

個人用途・ローカル+本番のみの制約下で、フロントエンド・バックエンド統合的な設定管理アプローチを評価する。

### 環境変数 + .env ファイル

最もシンプルな設定管理手法で、環境変数をファイルで管理する標準的アプローチ。

- 利点
  - 12-factor app 原則に準拠した業界標準手法
  - シンプルで理解しやすい構造
  - 言語・フレームワーク非依存の汎用性
  - Docker・CI/CD との統合が自然
  - 機密情報の環境分離が確実
- 欠点
  - 構造化データの表現が困難 (JSON の文字列化が必要)
  - 設定値の型安全性が保証されない
  - 設定の階層化・グループ化ができない
  - 設定値の妥当性検証が手動

フロントエンド対応:

- Vite の import.meta.env による環境変数取得
- .env.local、.env.production による環境分離
- VITE\_ プレフィックスによるフロントエンド公開制御

### YAML/TOML 設定ファイル

構造化された設定ファイル形式で、階層的な設定管理を提供。

- 利点
  - 階層構造による設定の論理的整理
  - 型安全性とスキーマ検証が可能
  - 人間が読みやすい形式
  - 複雑な設定の表現力が高い
  - 設定ファイルのバージョン管理が容易
- 欠点
  - 機密情報を設定ファイルに含められない
  - 環境変数との併用で複雑性が増す
  - フロントエンドでの設定読み込みが複雑
  - ファイル管理の追加負荷

フロントエンド対応:

- ビルド時設定注入によるフロントエンド配信
- 環境別設定ファイル (config.dev.yaml, config.prod.yaml)
- 機密情報は別途環境変数で管理

### Python 設定モジュール

Python のモジュール機能を活用した設定管理で、型安全性と柔軟性を両立。

- 利点
  - Python の型ヒントによる型安全性
  - Pydantic による設定検証・変換
  - IDE サポートによる開発効率向上
  - 設定の継承・組み合わせが柔軟
  - FastAPI との統合が自然
- 欠点
  - Python 専用でフロントエンドに適用不可
  - 設定ファイルがコードと混在
  - 機密情報は別途環境変数が必要
  - 非プログラマーには編集困難

フロントエンド対応:

- バックエンド API 経由での設定取得
- ビルド時設定注入との併用
- 環境変数による機密情報管理は別途実装

### 外部設定サービス

AWS Parameter Store、HashiCorp Vault 等のクラウド設定管理サービス利用。

- 利点
  - 機密情報の高度な暗号化・アクセス制御
  - 設定変更の履歴・監査機能
  - 複数環境・サービス間での設定共有
  - 動的設定変更が可能
- 欠点
  - 追加コスト・複雑性の大幅増加
  - ネットワーク依存による障害リスク
  - 個人用途にはオーバースペック
  - 一人開発制約に反する複雑性

フロントエンド対応:

- API 経由での設定取得
- 機密情報のセキュアな配信
- ただし個人用途には過剰

## 判断基準による評価

### シンプルさの比較

環境変数 + .env ファイルが最もシンプルで理解しやすく、一人開発制約に最適である。設定ファイル形式は階層化による複雑性、Python 設定モジュールはコード化による学習負荷、外部サービスは運用複雑性が増大する。

### セキュリティ基準適合の比較

全選択肢とも基本的なセキュリティ要件は満たすが、アプローチが異なる。環境変数方式は機密情報の環境分離が確実で、設定ファイル方式は構造化による検証強化、外部サービスは高度なセキュリティ機能を提供する。個人用途では環境変数による分離で十分である。

### 環境分離の比較

環境変数 + .env ファイルが最も確実な環境分離を提供する。ファイル名による明確な分離 (.env.local, .env.production) と、機密情報の環境変数化により、設定の混在リスクを排除できる。

### フロントエンド対応の比較

環境変数方式が最もフロントエンドに適している。Vite の標準機能による環境変数取得、VITE\_ プレフィックスによる公開制御、ビルド時注入による最適化が自然に利用できる。

### 既存技術親和性の比較

環境変数方式が最も技術非依存で、Python + FastAPI との統合も自然である。python-dotenv による .env ファイル読み込み、os.getenv による環境変数取得で、追加ライブラリなしに実装可能である。

## 最終選択と根拠

### 選択結果

<!-- GLOBAL_CONCLUSION_BEGIN: config-management-tech-selection -->

設定管理技術として環境変数 + .env ファイル方式を採用する。

<!-- GLOBAL_CONCLUSION_END: config-management-tech-selection -->

### 選択根拠

一人開発制約下でのシンプルさが決定要因である。12-factor app 原則に準拠した業界標準手法により学習負荷を最小化し、機密情報の環境分離を確実に実現する。Vite の標準機能によりフロントエンド対応も自然で、Python + FastAPI エコシステムとの親和性も高い。個人用途における基本的なセキュリティ要件を満たしながら、理解しやすく保守負荷の軽い設定管理を実現する。

### 実装方針

#### バックエンド設定管理

- python-dotenv による .env ファイル読み込み
- os.getenv による環境変数取得
- Pydantic Settings による型安全な設定クラス定義
- .env.local (開発用)、.env.production (本番用) による環境分離

#### フロントエンド設定管理

- Vite の import.meta.env による環境変数取得
- VITE\_ プレフィックスによる公開制御
- .env.local、.env.production による環境別設定
- ビルド時注入による最適化された設定配信

#### セキュリティ対応

- .env ファイルの .gitignore 追加による機密情報保護
- 環境変数による API キー・接続文字列の外部化
- 本番環境での環境変数直接設定による安全性確保
- フロントエンドでの機密情報非公開の徹底
